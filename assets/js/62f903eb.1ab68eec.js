"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[601],{30249:e=>{e.exports=JSON.parse('{"functions":[{"name":"CloneAsOwned","desc":"Returns a copy of the underlying data which can be freely modified by the client.","params":[],"returns":[{"desc":"","lua_type":"DataTable"}],"function_type":"method","source":{"line":103,"path":"src/Client.lua"}},{"name":"Iterate","desc":"Returns an iterator that goes over the values of the proxy.\\nFor some semblance of consistency,  prioritizes number indices first,\\nthen non-table values, and finally table values.\\nFor convenience, this is also used as the underlying implementation\\nfor the `__iter` metamethod for use in generalized `for` loops,\\nsuch as in the following example.\\n```lua\\nlocal UnifiedData = require(path.to.module).Client\\nlocal proxy = UnfiedData.GetProxy(\\"SomeData\\")\\nfor k, v in proxy do\\n    print(k, v, typeof(v)) --\x3e DataKey, AttributeValue | ClientProxy, typeof(AttributeValue) | \\"table\\"\\nend\\n```","params":[],"returns":[{"desc":"","lua_type":"() -> DataKey?, (AttributeValue | ClientProxy)?"}],"function_type":"method","source":{"line":123,"path":"src/Client.lua"}},{"name":"IsValid","desc":"Returns `true` if the underlying folder still exists, otherwise returns `false`","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":130,"path":"src/Client.lua"}},{"name":"IsLoaded","desc":"Returns `true` if all children of underlying folder have replicated, otherwise returns `false`","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":137,"path":"src/Client.lua"}},{"name":"WaitForLoaded","desc":"Returns the ClientProxy immediately if [ClientProxy:IsLoaded] resolves to true,\\notherwise halts the thread until it has fully replicated and then returns the proxy.\\nReturns `nil` if [ClientProxy:IsLoaded] does not resolve within `timeout` seconds,\\ndefault of 5 seconds","params":[{"name":"timeout","desc":"Default of 5","lua_type":"number?"},{"name":"pollRate","desc":"Default of 1/60","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"ClientProxy?"}],"function_type":"method","yields":true,"source":{"line":158,"path":"src/Client.lua"}},{"name":"OnKeyChanged","desc":"Fires given `callback` when ClientProxy[key] is changed to a new value, passing the new value to `callback`.","params":[{"name":"key","desc":"","lua_type":"DataKey"},{"name":"callback","desc":"","lua_type":"((AttributeValue | ClientProxy)?) -> ()"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection\\r\\n"}],"function_type":"method","source":{"line":171,"path":"src/Client.lua"}},{"name":"__iter","desc":"See [ClientProxy:Iterate] for details","params":[],"returns":[{"desc":"","lua_type":"DataKey, (AttributeValue | ClientProxy)"}],"function_type":"method","source":{"line":183,"path":"src/Client.lua"}}],"properties":[{"name":"Changed","desc":"Fires whenever a value is modified, sends relevant index [DataKey]","lua_type":"RBXScriptSignal","source":{"line":41,"path":"src/Client.lua"}},{"name":"Destroying","desc":"Fires when the relevant data has been removed, sends relevant index [DataKey]","lua_type":"RBXScriptSignal","source":{"line":45,"path":"src/Client.lua"}},{"name":"__folder","desc":"Underlying folder that contains subfolders and attributes that contains the serialized [DataTable]","lua_type":"Folder","private":true,"source":{"line":50,"path":"src/Client.lua"}},{"name":"__child_proxies","desc":"Cached proxies that are sub-tables of the relevant [DataTable]","lua_type":"{[DataKey]: ClientProxy}","private":true,"source":{"line":55,"path":"src/Client.lua"}}],"types":[],"name":"ClientProxy","desc":"Layer that manages automatically accessing the underlying folder which actually contains the serialized [DataTable].\\nSimilar to [ServerProxy], although client proxies are instead read-only (enforced by `table.freeze`) and have\\nsome additional tools and events to facilitate ease of use as a recipient.\\n\\nSimilar to [ServerProxy], ClientProxy is meant to have its type overridden to facilitate autocompletion.\\nThis is particularly useful for ClientProxy as it has some methods and values that [ServerProxy] does not contain.\\n```lua\\nlocal Player = game.Players.LocalPlayer\\nlocal UnifiedData = require(path.to.module.Client)\\ntype ScoreTable = {[string]: {current: number, delta: number}}\\nlocal ScoresProxy = UnifiedData.WaitForProxy(\\"scores\\") :: ScoreTable & UnifiedData.ClientProxy\\n```\\nBy overriding the type such as above, `ScoreProxy` will have methods such as [ClientProxy:IsValid]\\nand fields such as [ClientProxy.Changed] while still maintaining the tables own fields\\nas suggestions.","realm":["Client"],"source":{"line":34,"path":"src/Client.lua"}}')}}]);