"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[591],{4906:e=>{e.exports=JSON.parse('{"functions":[{"name":"__newindex","desc":"It should be noted that existing sub-tables are fully replaced and\\ndestroys the underlying folder, replacing it with a new one. As such,\\nany references to the old proxy are invalidated\\n(indicated by private field [ServerProxy.__valid] on the server and [ClientProxy:IsValid] on the client)","params":[{"name":"key","desc":"","lua_type":"DataKey"},{"name":"value","desc":"","lua_type":"(AttributeValue | DataTable)?"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":92,"path":"src/Server.lua"}},{"name":"__iter","desc":"Uses the same underlying implementation of [ClientProxy:Iterate] to iterate through the proxy; see page for details","params":[],"returns":[{"desc":"","lua_type":"DataKey, (AttributeValue | ClientProxy)"}],"function_type":"method","source":{"line":108,"path":"src/Server.lua"}}],"properties":[{"name":"__folder","desc":"Underlying folder that contains subfolders and attributes that contains the serialized [DataTable]","lua_type":"Folder","private":true,"source":{"line":43,"path":"src/Server.lua"}},{"name":"__child_proxies","desc":"Cached proxies that are sub-tables of the relevant [DataTable]","lua_type":"{[DataKey]: ClientProxy}","private":true,"source":{"line":48,"path":"src/Server.lua"}},{"name":"__valid","desc":"Boolean indicating that the underlying `__folder` still exists.","lua_type":"boolean","private":true,"source":{"line":53,"path":"src/Server.lua"}}],"types":[],"name":"ServerProxy","desc":"Layer that manages automatically modifying and accessing the underlying folder which actually contains the data.\\nThe main difference between client and server is that the server is allowed to modify it as it pleases,\\nwhile [ClientProxy] is completely read-only, enforced by `table.freeze`.\\n\\nAdditionally, ServerProxy is rather bare-bones compared to [ClientProxy] because this module is not\\nintended to share data between scripts on the server.\\n\\nProxies are intended to have their type overridden to facilitate auto-completion, such as in the following example.\\n```lua\\ntype Score = {PlayerName: string, Value: number}\\n-- Server.CreateTable returns a ServerProxy with the given data\\n-- Either override using :: operation\\nlocal scoreProxy = Server.CreateTable(Player.UserId, {PlayerName = Player.Name, Value = 0}) :: Score\\n-- Or by specifying the type of the variable\\nlocal scoreProxy: Score = Server.CreateTable(Player.UserId, {PlayerName = Player.Name, Value = 0})\\n```\\nBy doing so, the developer can read and modify the data as they would with a normal table while the\\nunderlying metamethods handle the Folders and Attributes in the background,\\nfacilitating replication to the clients.","realm":["Server"],"source":{"line":37,"path":"src/Server.lua"}}')}}]);