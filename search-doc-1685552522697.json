[{"title":"ServerProxy","type":0,"sectionRef":"#","url":"/UnifiedData/api/ServerProxy","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ServerProxy","url":"/UnifiedData/api/ServerProxy#functions","content":" "},{"title":"__newindex​","type":1,"pageTitle":"ServerProxy","url":"/UnifiedData/api/ServerProxy#__newindex","content":"This item only works when running on the server. Server &lt;/&gt; ServerProxy:__newindex( key: DataKey, value: (AttributeValue | DataTable)? ) → () It should be noted that existing sub-tables are fully replaced and destroys the underlying folder, replacing it with a new one. As such, any references to the old proxy are invalidated (indicated by private field ServerProxy.__valid on the server and ClientProxy:IsValid on the client)  "},{"title":"iterating over ServerProxy​","type":1,"pageTitle":"ServerProxy","url":"/UnifiedData/api/ServerProxy#__iter","content":"&lt;/&gt; for DataKey,(AttributeValue | ClientProxy) in ServerProxy do Uses the same underlying implementation of ClientProxy:Iterate to iterate through the proxy; see page for details "},{"title":"ClientProxy","type":0,"sectionRef":"#","url":"/UnifiedData/api/ClientProxy","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#Changed","content":"&lt;/&gt; ClientProxy.Changed: RBXScriptSignal  Fires whenever a value is modified, sends relevant index DataKey  "},{"title":"Destroying​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#Destroying","content":"&lt;/&gt; ClientProxy.Destroying: RBXScriptSignal  Fires when the relevant data has been removed, sends relevant index DataKey "},{"title":"Functions​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#functions","content":" "},{"title":"CloneAsOwned​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#CloneAsOwned","content":"&lt;/&gt; ClientProxy:CloneAsOwned() → DataTable Returns a copy of the underlying data which can be freely modified by the client.  "},{"title":"Iterate​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#Iterate","content":"&lt;/&gt; ClientProxy:Iterate() → () → DataKey?,(AttributeValue | ClientProxy)? Returns an iterator that goes over the values of the proxy. For some semblance of consistency, prioritizes number indices first, then non-table values, and finally table values. For convenience, this is also used as the underlying implementation for the __iter metamethod for use in generalized for loops, such as in the following example. local UnifiedData = require(path.to.module).Client local proxy = UnfiedData.GetProxy(&quot;SomeData&quot;) for k, v in proxy do print(k, v, typeof(v)) --&gt; DataKey, AttributeValue | ClientProxy, typeof(AttributeValue) | &quot;table&quot; end   "},{"title":"IsValid​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#IsValid","content":"&lt;/&gt; ClientProxy:IsValid() → boolean Returns true if the underlying folder still exists, otherwise returns false  "},{"title":"OnKeyChanged​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#OnKeyChanged","content":"&lt;/&gt; ClientProxy:OnKeyChanged( key: DataKey, callback: ((AttributeValue | ClientProxy)?) → () ) → RBXScriptConnection  Fires given callback when ClientProxy[key] is changed to a new value, passing the new value to callback.  "},{"title":"iterating over ClientProxy​","type":1,"pageTitle":"ClientProxy","url":"/UnifiedData/api/ClientProxy#__iter","content":"&lt;/&gt; for DataKey,(AttributeValue | ClientProxy) in ClientProxy do See ClientProxy:Iterate for details "},{"title":"Example","type":0,"sectionRef":"#","url":"/UnifiedData/docs/intro","content":"","keywords":""},{"title":"Assumptions​","type":1,"pageTitle":"Example","url":"/UnifiedData/docs/intro#assumptions","content":"The client and server should have access to the same UnifiedData ModuleScript. In this example, it'll just be a direct child of ReplicatedStorage. The code under Server is located in ServerScriptService while the code under Client is located in StarterPlayerScripts. "},{"title":"Server​","type":1,"pageTitle":"Example","url":"/UnifiedData/docs/intro#server","content":"--!strict local Players = game.Players -- We specifically grab the Server code for UnifiedData local UnifiedData = require(game.ReplicatedStorage.UnifiedData.Server) -- The second argument of CreateTable is optional; -- We could set it if say we wanted the creator to start with 9999 score -- This returns a ServerProxy; however by overriding the return type, -- it prevents mistakes when using strict type-checking local ScoreTable = UnifiedData.CreateTable(&quot;Score&quot;) :: {[string]: number} local function onPlayerJoined(player: Player) if ScoreTable[player.Name] == nil then ScoreTable[player.Name] = 0 end task.spawn(function() while player.Parent ~= nil do wait(1) ScoreTable[player.Name] = ScoreTable[player.Name] + 1 end end) end for _, player in pairs(Players:GetPlayers()) do onPlayerJoined(player) end Players.PlayerAdded:Connect(onPlayerJoined)  "},{"title":"Client​","type":1,"pageTitle":"Example","url":"/UnifiedData/docs/intro#client","content":"-- Here we grab the Client code for UnifiedData local UnifiedData = require(game.ReplicatedStorage.UnifiedData.Client) local Player = game.Players.LocalPlayer -- We could potentially use UnifiedData.GetProxy instead, however -- there's a chance that the data hasn't replicated yet, necessitating -- that we use UnifiedData.WaitForProxy instead. local ScoreTable = UnifiedData.WaitForProxy(&quot;Score&quot;) ScoreTable.Changed:Connect(function(name) if name == Player.Name then print(`Score is now {ScoreTable[name]}`) end end) wait(10) print(`My score is currently {ScoreTable[Player.Name]}`)  With all the code in place, when testing in studio you should see print statements in the output reporting the score for you, while effectively all you've done is make a table and modify it on the server and read from it on the client. "},{"title":"UnifiedData","type":0,"sectionRef":"#","url":"/UnifiedData/api/UnifiedData","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#types","content":" "},{"title":"AttributeValue​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#AttributeValue","content":"&lt;/&gt; type AttributeValue = string | boolean | number | UDim | UDim2 | BrickColor | Color3 | Vector2 | Vector3 | NumberSequence | ColorSequence | NumberRange | Rect  As the data replication is based on using Instance Attributes, only values that can be stored as Attributes are valid types to use. In the future, storing references to Instances may be facilitated using ObjectValues in the underlying code.  "},{"title":"DataKey​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#DataKey","content":"&lt;/&gt; type DataKey = number | string  "},{"title":"Functions​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#functions","content":" "},{"title":"GetProxy​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#GetProxy","content":"This item only works when running on the client. Client &lt;/&gt; UnifiedData.GetProxy(key: DataKey) → ClientProxy? If the data exists, returns its relevant ClientProxy or creates a new one. Otherwise returns nil.  "},{"title":"OnKeyAdded​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#OnKeyAdded","content":"This item only works when running on the client. Client &lt;/&gt; UnifiedData.OnKeyAdded( callback: (DataKey) → ()-- Callback to be fired when the server adds a new table ) → ()   "},{"title":"OnKeyRemoved​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#OnKeyRemoved","content":"This item only works when running on the client. Client &lt;/&gt; UnifiedData.OnKeyRemoved( callback: (DataKey) → ()-- Callback to be fired when the server removes a table ) → ()   "},{"title":"WaitForProxy​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#WaitForProxy","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; UnifiedData.WaitForProxy( key: DataKey, timeout: number? ) → ClientProxy? Essentially a wrapper around Client.GetProxy that will block the thread until timeout seconds occur (default of 5) if the relevant data doesn't yet exist  "},{"title":"CreateTable​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#CreateTable","content":"This item only works when running on the server. Server &lt;/&gt; UnifiedData.CreateTable( key: DataKey, t: DataTable? ) → ServerProxy "},{"title":"Types","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData##","content":""},{"title":"​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#DataTable","content":"type DataTable = {[DataKey]: AttributeValue | DataTable}  Serializes the given table t or creates an empty one and returns a ServerProxy that points to the &quot;root&quot; of the given table.  "},{"title":"GetProxy​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#GetProxy","content":"This item only works when running on the server. Server &lt;/&gt; UnifiedData.GetProxy(key: DataKey) → ServerProxy?   "},{"title":"RemoveTable​","type":1,"pageTitle":"UnifiedData","url":"/UnifiedData/api/UnifiedData#RemoveTable","content":"This item only works when running on the server. Server &lt;/&gt; UnifiedData.RemoveTable(key: DataKey) → ()  "}]